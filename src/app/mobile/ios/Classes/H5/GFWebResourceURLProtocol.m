#import "GFWebResourceURLProtocol.h"
#import "GFWebResourceInterceptor.h"
#import "GFWebResourceCache.h"
#import "NSString+GFAdditions.h"

#define JM_WEB_REQUEST_TRACKING_KEY     @"jm_req_tracking"

@interface GFWebResourceURLProtocol () <NSURLConnectionDelegate>

// the key associated cached content, generated by url and path extension
@property (nonatomic, strong) NSString *cacheKey;

// resource connection,
@property (nonatomic, strong) NSURLConnection *internalConnection;
@property (nonatomic, strong) NSURLResponse *internalResponse;

// the css and js both tiny text body, so save it in memory directly,
// flush it to disk when all content returns from server.
@property (nonatomic, strong) NSMutableData *responseData;

@end

@implementation GFWebResourceURLProtocol

//////////////////////////////////////////////////////////////////////////////////

#pragma mark -
#pragma mark private methods

+ (NSString *)pathExtensionFromComboURL:(NSURL *)url {
  NSString *extension = nil;
  
  // the combo url format like: http://tb.cn/g??a-v1.js,b-v2.js,c-v3.js
  NSString *query = [url query];
  if (query != nil && [query hasPrefix:@"?"]) {
    NSArray *components = [query componentsSeparatedByString:@","];
    if (components != nil && [components count] > 0) {
      // all the resources in combo url must same type,
      // so return the extension of first item
      extension = [components[0] pathExtension];
    }
  }
  
  return extension;
}

// check the request is used to get combo content from server
+ (BOOL)isSupportedComboURLRequest:(NSURLRequest *)request {
  NSString *extension = [GFWebResourceURLProtocol pathExtensionFromComboURL:request.URL];
  BOOL supported = [[GFWebResourceInterceptor globalWebResourceInterceptor] isSupportedPathExtension:extension];
  
  return supported;
}

// search reference url or host from request header fields
+ (NSString *)getHostInRequest:(NSURLRequest *)request path:(NSString **)path {
  NSDictionary *fields = [request allHTTPHeaderFields];
  
  NSString *host = request.URL.host;
  
  // search 'Referer' field at firstly
  NSString *referer = fields[@"Referer"];
  if (referer != nil && [referer length] > 0) {
    NSURL *url = [NSURL URLWithString:referer];
    host = [url host];
    
    if (path != NULL) {
      *path = [url path];
    }
    
  } else {
    if (fields[@"Host"]) {
      host = fields[@"Host"];
    }
  }
  
  if (host != nil && [host hasPrefix:@"www."]) {
    // remove "www." from host
    host = ([host length] > 4) ? [host substringFromIndex:4] : nil;
  }
  
  return host;
}

// generate the cache content filename base on current request url
- (NSString *)cacheContentNameFromURL:(NSURL *)url {
  // the fully url as unique key
  NSString *prefix = [[url absoluteString] jm_MD5Digest];
  
  // save the path extension to generate file MIME type at later
  NSString *extension = [[[url lastPathComponent] pathExtension] lowercaseString];
  if (extension == nil || [extension length] == 0) {
    // get the extension from combo url
    extension = [GFWebResourceURLProtocol pathExtensionFromComboURL:url];
  }
  
  NSString *filename = [prefix stringByAppendingFormat:@".%@", extension ? : @""];
  
  return filename;
}

// build response with specified data
- (NSHTTPURLResponse *)buildResponseWithData:(NSString *)data {
  return nil;
}


//////////////////////////////////////////////////////////////////////////////////

#pragma mark -
#pragma mark public methods

// override
+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
  GFWebResourceInterceptor *interceptor
  = [GFWebResourceInterceptor globalWebResourceInterceptor];
  
  // step 1, check web resource interceptor is opening
  if (!interceptor.settings.enabled) return NO; // not support web resource interceptor
  
  // step 2, check the request did marked
  id prop = [NSURLProtocol propertyForKey:JM_WEB_REQUEST_TRACKING_KEY inRequest:request];
  if (prop != nil) return NO; // aviod loading cycle
  
  // step 3, check the scheme of request
  NSString *scheme = [request.URL scheme];
  if (scheme == nil) return NO; // the request schema can not be nil
  
  scheme = [scheme lowercaseString];
  if (!([scheme isEqualToString:@"https"]
        || [scheme isEqualToString:@"http"])) {
    return NO; // for now, the scheme should be 'http' or 'https'
  }
  
  // step 4, check the path extension of request was supported or not
  NSString *extension = [[[request.URL lastPathComponent] pathExtension] lowercaseString];
  if (extension == nil || [extension length] == 0) {
    // check it was supported combo url when path extension is nil
    if (![GFWebResourceURLProtocol isSupportedComboURLRequest:request]) return NO; // not support
    
  } else {
    if (![interceptor isSupportedPathExtension:extension]) return NO; // not support
    
    NSString *query = [request.URL query];
    if (query != nil && [query length] > 0) return NO; // skip the url with query string
  }
  
  // setp 5, check the reference host is in black/white host
  NSString *path = nil;
  NSString *host = [GFWebResourceURLProtocol getHostInRequest:request path:&path];
  if (host != nil) {
    if (path != nil) {
      NSString *urlPath = [host stringByAppendingPathComponent:path];
      // check host is in blacklist
      if ([interceptor isBlacklistWithRequestPath:urlPath]) {
        return NO;
      }
    }
    
    // check host is in whitelist
    if ([interceptor isWhitelistHost:host]) {
      return YES; // can handle the request use custom protocol
    }
  }
  
  return NO;
}

// override
+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
  return request;
}

// override
- (void)startLoading {
  NSURL *requestURL = self.request.URL;
  
  // generate key for local cache content
  self.cacheKey = [self cacheContentNameFromURL:requestURL];
  
  GFWebResourceInterceptor *interceptor = [GFWebResourceInterceptor globalWebResourceInterceptor];
  
  NSData *cacheData = nil;
  NSURLResponse *customResponse = nil;
  if ([interceptor.cache hasCacheForKey:_cacheKey]) { // check cache data is available
    // load cache data with associated key
    cacheData = [interceptor.cache cacheDataForKey:_cacheKey
                                               url:requestURL
                                          response:&customResponse];
    
    if (cacheData == nil) {
      // the cache index did expired, remove it form cache index table
      [interceptor.cache removeCacheIndexForKey:_cacheKey];
    }
  }
  
  if (cacheData != nil) {
    // notify did receive response
    [self.client URLProtocol:self
          didReceiveResponse:customResponse
          cacheStoragePolicy:NSURLCacheStorageAllowedInMemoryOnly];
    
    // notify did finish load data
    [self.client URLProtocol:self didLoadData:cacheData];
    
    // notify did finish loading
    [self.client URLProtocolDidFinishLoading:self];
    
  } else {
    NSMutableURLRequest *request = [self.request mutableCopy];
    [NSURLProtocol setProperty:@(YES) forKey:JM_WEB_REQUEST_TRACKING_KEY inRequest:request];
    
    self.internalConnection = [NSURLConnection connectionWithRequest:request delegate:self];
  }
}

// override
- (void)stopLoading {
  [self.internalConnection cancel];
  
  self.responseData = nil;
}


//////////////////////////////////////////////////////////////////////////////////

#pragma mark -
#pragma mark NSURLConenction delegate methods

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
  [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
  
  self.internalResponse = response;
  self.responseData = [[NSMutableData alloc] init];
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
  [self.client URLProtocol:self didLoadData:data];
  
  [self.responseData appendData:data];
}

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
  [self.client URLProtocol:self didFailWithError:error];
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
  [self.client URLProtocolDidFinishLoading:self];
  
  if ([self.internalResponse isKindOfClass:[NSHTTPURLResponse class]]) {
    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)self.internalResponse;
    
    // for now, the content length of combo resource does not match with
    // 'Content-Length' in response header. So ignore content length now.
    if (httpResponse.statusCode == 200) {
      
      // store cache response data
      GFWebResourceInterceptor *interceptor = [GFWebResourceInterceptor globalWebResourceInterceptor];
      [interceptor.cache storeCacheData:_responseData
                               response:_internalResponse
                                 forKey:_cacheKey
                        completionBlock:nil];
    }
  }
}

+ (NSString *)headerFieldValueInResponse:(NSHTTPURLResponse *)response forKey:(NSString *)key {
  if (key == nil) return nil;
  
  NSDictionary *fields = [response allHeaderFields];
  NSString *value = fields[key];
  if (value == nil) {
    // the network framework may be change the name of header field to lowercase
    value = fields[[key lowercaseString]];
  }
  
  return value;
}

+ (BOOL)isValidContentLengthInResponse:(NSHTTPURLResponse *)response withData:(NSData *)data {
  BOOL isValid = NO;
  NSString *contentLength = [self headerFieldValueInResponse:response
                                                      forKey:@"Content-Length"];
  
  if (contentLength != nil && [contentLength length] > 0) {
    isValid = [data length] == [contentLength integerValue];
  }
  
  return isValid;
}

@end
